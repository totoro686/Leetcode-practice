method 1: quick select

// [3,1,4,5,6]

class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, k);
    }
    
    private int quickSelect(int[] nums, int left, int right, int k){
        int pivot = left;
        
        for(int i = left; i < right; i++){
            if(nums[i] <= nums[right]){
                if(pivot != i){
                    swap(nums, pivot, i);
                }
                pivot++;
            }            
        }
        swap(nums, pivot, right);
        
        int count = right - pivot + 1;
        if(count == k){
            return nums[pivot];
        } else if(count > k) {
            return quickSelect(nums, pivot + 1, right, k);
        } else {
            return quickSelect(nums, left, pivot - 1, k - count);
        }
        
    }
    
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}


method 2: priorityqueue:
class Solution {
    public int findKthLargest(int[] nums, int k) {
        if(nums.length == 0) return 0;
        PriorityQueue<Integer> q = new PriorityQueue<>();
        
        for(int i = 0; i < nums.length; i++){
            q.add(nums[i]);
            if(q.size() > k){
                q.poll();
            }
        }
        
        return q.poll();
    }
}


method 3: sort
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length - k];
    }
}

